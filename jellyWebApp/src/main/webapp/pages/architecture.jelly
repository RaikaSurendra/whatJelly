<?xml version="1.0"?>
<j:jelly xmlns:j="jelly:core" xmlns:app="app">
<html>
<head>
    <title>Jelly Architecture - Interactive Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .header {
            background: rgba(0,0,0,0.2);
            color: white;
            padding: 30px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        .menu {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        .menu a {
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            margin: 0 10px;
            display: inline-block;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            transition: all 0.3s;
        }
        .menu a:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        .container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
        }
        .viz-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        h2 {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-top: 0;
        }
        .node {
            cursor: pointer;
            transition: all 0.3s;
        }
        .node:hover {
            filter: brightness(1.2);
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
        }
        .link-animated {
            animation: dash 2s linear infinite;
        }
        @keyframes dash {
            to {
                stroke-dashoffset: -20;
            }
        }
        .tooltip {
            position: fixed;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            max-width: 350px;
            z-index: 10000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
            transform: translateY(10px);
        }
        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }
        .tooltip h4 {
            margin: 0 0 8px 0;
            font-size: 16px;
            border-bottom: 2px solid rgba(255,255,255,0.3);
            padding-bottom: 6px;
        }
        .tooltip p {
            margin: 6px 0;
            line-height: 1.5;
        }
        .tooltip code {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        .code-box {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
        }
        .step {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .step-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }
        #flowchart {
            width: 100%;
            height: 500px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }
        #lifecycle {
            width: 100%;
            height: 500px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }
        .viz-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .viz-node:hover {
            filter: brightness(1.2);
            transform: scale(1.1);
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        .highlight-box {
            background: #fff9e6;
            border: 2px solid #ffb300;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üèóÔ∏è Jelly Architecture Visualization</h1>
        <p>Interactive diagrams showing how Jelly processes your templates</p>
    </div>

    <div class="menu">
        <a href="/">Home</a>
        <a href="/users.jelly">Users</a>
        <a href="/products.jelly">Products</a>
        <a href="/dashboard.jelly">Dashboard</a>
        <a href="/architecture.jelly">Architecture</a>
    </div>

    <div class="container">
        <!-- Request Lifecycle -->
        <div class="viz-section">
            <h2>üìä Request Lifecycle Visualization</h2>
            <p>Watch how a request flows through the system when you access a Jelly page:</p>
            
            <div style="text-align: center; margin: 20px 0;">
                <button onclick="animateLifecycle()">‚ñ∂Ô∏è Animate Request Flow</button>
                <button onclick="resetLifecycle()">üîÑ Reset</button>
            </div>
            
            <div id="lifecycle" style="width: 100%; height: 500px;"></div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>HTTP Layer</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>Servlet Layer</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span>Jelly Engine</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #27ae60;"></div>
                    <span>Database</span>
                </div>
            </div>
        </div>

        <!-- TagLibrary Architecture -->
        <div class="viz-section">
            <h2>üèõÔ∏è TagLibrary & TagSupport Architecture</h2>
            <p>Interactive diagram showing how custom tags are registered and used:</p>
            
            <div style="text-align: center; margin: 20px 0;">
                <button onclick="animateTagLibrary()">‚ñ∂Ô∏è Animate Tag Registration</button>
                <button onclick="resetTagLibrary()">üîÑ Reset</button>
            </div>
            
            <div id="taglibrary" style="width: 100%; height: 550px;"></div>
        </div>

        <!-- Tag Processing Flow -->
        <div class="viz-section">
            <h2>üîß Tag Processing Flow</h2>
            <p>See how Jelly processes custom tags step by step:</p>
            
            <div style="text-align: center; margin: 20px 0;">
                <button onclick="animateTagProcessing()">‚ñ∂Ô∏è Animate Tag Processing</button>
                <button onclick="resetTagProcessing()">üîÑ Reset</button>
            </div>
            
            <div id="flowchart" style="width: 100%; height: 600px;"></div>
        </div>

        <!-- Detailed Step-by-Step -->
        <div class="viz-section">
            <h2>üìù Detailed Processing Steps</h2>
            
            <div class="step">
                <span class="step-number">1</span>
                <strong>Browser Request</strong>
                <p>User requests <code>http://localhost:8080/users.jelly</code></p>
                <div class="code-box">GET /users.jelly HTTP/1.1
Host: localhost:8080</div>
            </div>

            <div class="step">
                <span class="step-number">2</span>
                <strong>Jetty Server Receives Request</strong>
                <p>Embedded Jetty server running on port 8080 receives the HTTP request</p>
            </div>

            <div class="step">
                <span class="step-number">3</span>
                <strong>Servlet Mapping</strong>
                <p>JellyServlet is mapped to handle <code>*.jelly</code> patterns</p>
                <div class="code-box">ServletHolder jellyServlet = new ServletHolder("jelly", new JellyServlet());
context.addServlet(jellyServlet, "*.jelly");</div>
            </div>

            <div class="step">
                <span class="step-number">4</span>
                <strong>JellyServlet.doGet() Invoked</strong>
                <p>The servlet's <code>doGet()</code> method is called with request and response objects</p>
            </div>

            <div class="step">
                <span class="step-number">5</span>
                <strong>Load Jelly Template</strong>
                <p>Servlet loads the .jelly file from <code>src/main/webapp/pages/</code></p>
                <div class="code-box">String jellyPath = "/pages/users.jelly";
URL jellyUrl = getServletContext().getResource(jellyPath);</div>
            </div>

            <div class="step">
                <span class="step-number">6</span>
                <strong>Create JellyContext</strong>
                <p>A new context is created to store variables and tag libraries</p>
                <div class="code-box">JellyContext context = new JellyContext();
context.registerTagLibrary("app", new AppTagLibrary());</div>
            </div>

            <div class="step">
                <span class="step-number">7</span>
                <strong>Add Context Variables</strong>
                <p>Request, session, and parameters are added to the context</p>
                <div class="code-box">context.setVariable("request", request);
context.setVariable("session", request.getSession());</div>
            </div>

            <div class="step">
                <span class="step-number">8</span>
                <strong>Compile Jelly Script</strong>
                <p>The XML template is parsed and compiled into an executable script</p>
                <div class="code-box">Script script = context.compileScript(jellyUrl);</div>
            </div>

            <div class="step">
                <span class="step-number">9</span>
                <strong>Execute Script</strong>
                <p>The script runs, processing each tag encountered:</p>
                <div class="highlight-box">
                    <h3>Tag Execution Example: &lt;app:sqlQuery&gt;</h3>
                    <ol>
                        <li>Parser encounters <code>&lt;app:sqlQuery var="users"&gt;</code></li>
                        <li>Looks up "app" namespace ‚Üí finds AppTagLibrary</li>
                        <li>Looks up "sqlQuery" ‚Üí finds SqlQueryTag class</li>
                        <li>Creates new <code>SqlQueryTag()</code> instance</li>
                        <li>Calls <code>setVar("users")</code></li>
                        <li>Injects JellyContext into tag</li>
                        <li>Reads SQL from tag body: <code>SELECT * FROM users</code></li>
                        <li>Tag executes SQL query against H2 database</li>
                        <li>Results stored in context: <code>context.setVariable("users", resultList)</code></li>
                        <li>Next tags can access <code>${users}</code></li>
                    </ol>
                </div>
            </div>

            <div class="step">
                <span class="step-number">10</span>
                <strong>JEXL Expression Evaluation</strong>
                <p>When <code>${user.name}</code> is encountered:</p>
                <div class="code-box">// Jelly uses JEXL to evaluate expressions
${user.name}

// JEXL looks up "user" in context
Object userObj = context.getVariable("user");

// Calls getName() method via reflection
String name = ((User) userObj).getName();</div>
            </div>

            <div class="step">
                <span class="step-number">11</span>
                <strong>Generate HTML Output</strong>
                <p>All static HTML and dynamic content is written to XMLOutput</p>
                <div class="code-box">XMLOutput output = XMLOutput.createXMLOutput(stringWriter);
script.run(context, output);
output.flush();</div>
            </div>

            <div class="step">
                <span class="step-number">12</span>
                <strong>Send Response</strong>
                <p>Final HTML is sent back to the browser</p>
                <div class="code-box">response.setContentType("text/html;charset=UTF-8");
PrintWriter out = response.getWriter();
out.write(stringWriter.toString());</div>
            </div>
        </div>

        <!-- Custom Tag Architecture -->
        <div class="viz-section">
            <h2>üè∑Ô∏è Custom Tag Architecture</h2>
            
            <div class="highlight-box">
                <h3>How Custom Tags Work</h3>
                <p>Custom tags extend Jelly's functionality by adding domain-specific operations:</p>
                
                <div class="code-box">// 1. Tag Definition (Java)
public class SqlQueryTag extends TagSupport {
    private String var;
    
    public void setVar(String var) {
        this.var = var;
    }
    
    @Override
    public void doTag(XMLOutput output) throws JellyTagException {
        String sql = getBodyText();
        List&lt;Map&lt;String, Object&gt;&gt; results = executeQuery(sql);
        context.setVariable(var, results);
    }
}

// 2. Tag Library Registration
public class AppTagLibrary extends TagLibrary {
    public AppTagLibrary() {
        registerTag("sqlQuery", SqlQueryTag.class);
    }
}

// 3. Register with Context
context.registerTagLibrary("app", new AppTagLibrary());

// 4. Use in Template
&lt;app:sqlQuery var="users"&gt;
    SELECT * FROM users
&lt;/app:sqlQuery&gt;</div>
            </div>
        </div>

        <!-- Database Integration -->
        <div class="viz-section">
            <h2>üíæ Database Integration Flow</h2>
            
            <div class="step">
                <span class="step-number">1</span>
                <strong>Connection Pool Initialization</strong>
                <p>DatabaseManager creates a connection pool at startup</p>
                <div class="code-box">BasicDataSource dataSource = new BasicDataSource();
dataSource.setUrl("jdbc:h2:mem:testdb");
dataSource.setMaxTotal(10);</div>
            </div>

            <div class="step">
                <span class="step-number">2</span>
                <strong>SQL Tag Execution</strong>
                <p>When &lt;app:sqlQuery&gt; executes:</p>
                <div class="code-box">Connection conn = DatabaseManager.getConnection();
PreparedStatement stmt = conn.prepareStatement(sql);
ResultSet rs = stmt.executeQuery();</div>
            </div>

            <div class="step">
                <span class="step-number">3</span>
                <strong>Result Processing</strong>
                <p>ResultSet is converted to List&lt;Map&gt; for easy access in Jelly</p>
                <div class="code-box">while (rs.next()) {
    Map&lt;String, Object&gt; row = new HashMap&lt;&gt;();
    row.put("name", rs.getString("name"));
    row.put("email", rs.getString("email"));
    results.add(row);
}</div>
            </div>

            <div class="step">
                <span class="step-number">4</span>
                <strong>Store in Context</strong>
                <p>Results are stored with the variable name</p>
                <div class="code-box">context.setVariable(var, results);
context.setVariable(var + "_count", results.size());</div>
            </div>

            <div class="step">
                <span class="step-number">5</span>
                <strong>Access in Template</strong>
                <p>Other tags can now iterate over the results</p>
                <div class="code-box">&lt;j:forEach var="user" items="${users}"&gt;
    &lt;p&gt;${user.name} - ${user.email}&lt;/p&gt;
&lt;/j:forEach&gt;</div>
            </div>
        </div>

        <!-- Real Example -->
        <div class="viz-section">
            <h2>üéØ Real Example: User List Page</h2>
            <p>Let's trace how the users.jelly page is processed:</p>
            
            <div class="code-box">&lt;?xml version="1.0"?&gt;
&lt;j:jelly xmlns:j="jelly:core" xmlns:app="app"&gt;
&lt;html&gt;
&lt;body&gt;
    &lt;h1&gt;Users&lt;/h1&gt;
    
    &lt;!-- STEP 1: Execute SQL query --&gt;
    &lt;app:sqlQuery var="users"&gt;
        SELECT id, name, email, role FROM users WHERE active = TRUE
    &lt;/app:sqlQuery&gt;
    
    &lt;!-- STEP 2: Display count --&gt;
    &lt;p&gt;Total users: ${users_count}&lt;/p&gt;
    
    &lt;!-- STEP 3: Iterate and display --&gt;
    &lt;j:forEach var="user" items="${users}"&gt;
        &lt;div&gt;
            &lt;h3&gt;${user.name}&lt;/h3&gt;
            &lt;p&gt;Email: ${user.email}&lt;/p&gt;
            &lt;p&gt;Role: ${user.role}&lt;/p&gt;
        &lt;/div&gt;
    &lt;/j:forEach&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/j:jelly&gt;</div>

            <div class="highlight-box">
                <h3>Behind the Scenes:</h3>
                <ol>
                    <li>SqlQueryTag.doTag() is called</li>
                    <li>getBodyText() returns the SQL string</li>
                    <li>DatabaseManager.getConnection() gets a connection</li>
                    <li>SQL is executed: <code>SELECT id, name, email, role FROM users WHERE active = TRUE</code></li>
                    <li>ResultSet is converted to List&lt;Map&gt;</li>
                    <li>context.setVariable("users", list) stores results</li>
                    <li>context.setVariable("users_count", 5) stores count</li>
                    <li>ForEach tag iterates, setting "user" for each iteration</li>
                    <li>JEXL evaluates ${user.name} by looking up "user" then calling .get("name")</li>
                    <li>Final HTML with all data is generated</li>
                </ol>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script><![CDATA[
        // Request Lifecycle Visualization - Enhanced
        function createLifecycle() {
            const container = d3.select("#lifecycle");
            container.selectAll("*").remove();
            
            const width = 1200;
            const height = 500;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Add gradients
            const defs = svg.append("defs");
            
            // Gradient for each color
            const colors = [
                {id: "blue-gradient", color1: "#3498db", color2: "#2980b9"},
                {id: "red-gradient", color1: "#e74c3c", color2: "#c0392b"},
                {id: "orange-gradient", color1: "#f39c12", color2: "#e67e22"},
                {id: "green-gradient", color1: "#27ae60", color2: "#229954"}
            ];
            
            colors.forEach(c => {
                const gradient = defs.append("radialGradient")
                    .attr("id", c.id);
                gradient.append("stop")
                    .attr("offset", "0%")
                    .attr("stop-color", c.color1);
                gradient.append("stop")
                    .attr("offset", "100%")
                    .attr("stop-color", c.color2);
            });
            
            // Drop shadow filter
            const filter = defs.append("filter")
                .attr("id", "drop-shadow")
                .attr("height", "130%");
            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3);
            filter.append("feOffset")
                .attr("dx", 2)
                .attr("dy", 2)
                .attr("result", "offsetblur");
            const feMerge = filter.append("feMerge");
            feMerge.append("feMergeNode");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");
            
            // Fixed positions for 12 nodes with detailed info
            const nodes = [
                { id: 1, name: "Browser", x: 100, y: 100, color: "#3498db", 
                  desc: "User Browser", 
                  detail: "Client initiates HTTP GET request to http://localhost:8080/users.jelly",
                  tech: "HTTP/1.1" },
                { id: 2, name: "Jetty", x: 250, y: 100, color: "#3498db",
                  desc: "Jetty Server",
                  detail: "Embedded Jetty 9.4 server listening on port 8080 receives the request",
                  tech: "org.eclipse.jetty.server.Server" },
                { id: 3, name: "Servlet", x: 400, y: 100, color: "#e74c3c",
                  desc: "JellyServlet",
                  detail: "Servlet mapped to *.jelly pattern handles the request via doGet() method",
                  tech: "com.example.webapp.JellyServlet" },
                { id: 4, name: "Load", x: 550, y: 100, color: "#e74c3c",
                  desc: "Load Template",
                  detail: "Reads users.jelly from src/main/webapp/pages/ using ServletContext.getResource()",
                  tech: "URL jellyUrl" },
                { id: 5, name: "Context", x: 700, y: 100, color: "#f39c12",
                  desc: "JellyContext",
                  detail: "Creates execution context, registers AppTagLibrary, adds request/session variables",
                  tech: "org.apache.commons.jelly.JellyContext" },
                { id: 6, name: "Compile", x: 850, y: 100, color: "#f39c12",
                  desc: "Compile Script",
                  detail: "Parses XML template and compiles into executable Jelly Script object",
                  tech: "Script script = context.compileScript()" },
                { id: 7, name: "Execute", x: 850, y: 250, color: "#f39c12",
                  desc: "Execute Tags",
                  detail: "Runs script.run() which processes each tag: core tags, custom tags, and JEXL expressions",
                  tech: "script.run(context, output)" },
                { id: 8, name: "SQL", x: 700, y: 250, color: "#27ae60",
                  desc: "SQL Query Tag",
                  detail: "SqlQueryTag.doTag() extracts SQL from body, executes query via JDBC",
                  tech: "<app:sqlQuery var='users'>" },
                { id: 9, name: "Database", x: 700, y: 400, color: "#27ae60",
                  desc: "H2 Database",
                  detail: "In-memory H2 database executes SELECT * FROM users query and returns ResultSet",
                  tech: "jdbc:h2:mem:testdb" },
                { id: 10, name: "Store", x: 550, y: 400, color: "#f39c12",
                  desc: "Store Results",
                  detail: "Converts ResultSet to List<Map>, stores in context as 'users' variable",
                  tech: "context.setVariable('users', list)" },
                { id: 11, name: "HTML", x: 400, y: 400, color: "#e74c3c",
                  desc: "Generate HTML",
                  detail: "XMLOutput writes final HTML with all dynamic content replaced by actual values",
                  tech: "XMLOutput.createXMLOutput()" },
                { id: 12, name: "Response", x: 250, y: 400, color: "#3498db",
                  desc: "Send Response",
                  detail: "HTTP 200 OK with Content-Type: text/html returned to browser with complete page",
                  tech: "response.getWriter().write()" }
            ];
            
            // Draw connecting lines with animation
            for (let i = 0; i < nodes.length - 1; i++) {
                const line = svg.append("line")
                    .attr("x1", nodes[i].x)
                    .attr("y1", nodes[i].y)
                    .attr("x2", nodes[i + 1].x)
                    .attr("y2", nodes[i + 1].y)
                    .attr("stroke", "#7f8c8d")
                    .attr("stroke-width", 3)
                    .attr("stroke-dasharray", "8,4")
                    .attr("opacity", 0.6);
                
                // Animate line appearance
                line.style("stroke-dashoffset", 1000)
                    .transition()
                    .duration(1000)
                    .delay(i * 100)
                    .style("stroke-dashoffset", 0);
            }
            
            // Draw nodes with enhanced styling
            nodes.forEach((node, i) => {
                const nodeGroup = svg.append("g")
                    .attr("class", "viz-node")
                    .style("cursor", "pointer");
                
                // Get gradient based on color
                let gradientId = "blue-gradient";
                if (node.color === "#e74c3c") gradientId = "red-gradient";
                else if (node.color === "#f39c12") gradientId = "orange-gradient";
                else if (node.color === "#27ae60") gradientId = "green-gradient";
                
                // Circle with gradient and shadow
                const circle = nodeGroup.append("circle")
                    .attr("cx", node.x)
                    .attr("cy", node.y)
                    .attr("r", 0)
                    .attr("fill", `url(#${gradientId})`)
                    .attr("stroke", "white")
                    .attr("stroke-width", 4)
                    .attr("filter", "url(#drop-shadow)");
                
                // Animate circle appearance
                circle.transition()
                    .duration(600)
                    .delay(i * 80)
                    .attr("r", 40);
                
                // ID inside circle
                nodeGroup.append("text")
                    .attr("x", node.x)
                    .attr("y", node.y + 6)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "16px")
                    .attr("font-weight", "bold")
                    .attr("opacity", 0)
                    .text(node.id)
                    .transition()
                    .duration(300)
                    .delay(i * 80 + 600)
                    .attr("opacity", 1);
                
                // Label below with background
                nodeGroup.append("rect")
                    .attr("x", node.x - 45)
                    .attr("y", node.y + 48)
                    .attr("width", 90)
                    .attr("height", 22)
                    .attr("rx", 11)
                    .attr("fill", "rgba(0,0,0,0.7)")
                    .attr("opacity", 0)
                    .transition()
                    .duration(300)
                    .delay(i * 80 + 600)
                    .attr("opacity", 1);
                
                nodeGroup.append("text")
                    .attr("x", node.x)
                    .attr("y", node.y + 63)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "13px")
                    .attr("font-weight", "bold")
                    .attr("fill", "white")
                    .attr("opacity", 0)
                    .text(node.name)
                    .transition()
                    .duration(300)
                    .delay(i * 80 + 600)
                    .attr("opacity", 1);
                
                // Enhanced hover effect with tooltip
                nodeGroup.on("mouseover", function(event) {
                    d3.select(this).select("circle")
                        .transition()
                        .duration(200)
                        .attr("r", 45)
                        .attr("stroke-width", 5);
                    
                    // Show tooltip
                    const tooltip = d3.select("#tooltip");
                    tooltip.html(`
                        <h4>Step ${node.id}: ${node.desc}</h4>
                        <p><strong>Function:</strong> ${node.detail}</p>
                        <p><strong>Technology:</strong> <code>${node.tech}</code></p>
                    `);
                    tooltip.classed("show", true);
                    
                    // Position tooltip
                    const rect = event.target.getBoundingClientRect();
                    tooltip.style("left", (rect.left + rect.width / 2 - 175) + "px")
                           .style("top", (rect.bottom + 10) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this).select("circle")
                        .transition()
                        .duration(200)
                        .attr("r", 40)
                        .attr("stroke-width", 4);
                    
                    d3.select("#tooltip").classed("show", false);
                });
            });
        }
        
        function animateLifecycle() {
            // Recreate with animation
            createLifecycle();
        }
        
        function resetLifecycle() {
            createLifecycle();
        }
        
        // TagLibrary Architecture Visualization
        function createTagLibrary() {
            const container = d3.select("#taglibrary");
            container.selectAll("*").remove();
            
            const width = 1200;
            const height = 550;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Add gradients
            const defs = svg.append("defs");
            const gradient = defs.append("linearGradient")
                .attr("id", "class-gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");
            gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "#8e44ad");
            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "#9b59b6");
            
            // Class boxes
            const classes = [
                { name: "TagSupport", x: 200, y: 50, width: 200, height: 80, 
                  desc: "Base class for all custom tags",
                  methods: ["doTag()", "setContext()", "getBodyText()"],
                  color: "url(#class-gradient)" },
                { name: "SqlQueryTag", x: 50, y: 200, width: 180, height: 100,
                  desc: "Executes SQL queries",
                  methods: ["setVar()", "doTag()", "executeQuery()"],
                  color: "#27ae60" },
                { name: "SqlUpdateTag", x: 250, y: 200, width: 180, height: 100,
                  desc: "Executes SQL updates",
                  methods: ["setVar()", "doTag()", "executeUpdate()"],
                  color: "#e74c3c" },
                { name: "FormatDateTag", x: 450, y: 200, width: 180, height: 100,
                  desc: "Formats dates",
                  methods: ["setValue()", "setPattern()", "doTag()"],
                  color: "#3498db" },
                { name: "AppTagLibrary", x: 750, y: 125, width: 220, height: 120,
                  desc: "Registers all custom tags",
                  methods: ["registerTag('sqlQuery')", "registerTag('sqlUpdate')", "registerTag('formatDate')"],
                  color: "#f39c12" },
                { name: "JellyContext", x: 750, y: 320, width: 220, height: 80,
                  desc: "Runtime execution context",
                  methods: ["registerTagLibrary()", "setVariable()", "getVariable()"],
                  color: "#16a085" }
            ];
            
            // Draw inheritance arrows
            const inheritanceLines = [
                { x1: 240, y1: 130, x2: 140, y2: 200 },
                { x1: 300, y1: 130, x2: 340, y2: 200 },
                { x1: 360, y1: 130, x2: 540, y2: 200 }
            ];
            
            inheritanceLines.forEach((line, i) => {
                const l = svg.append("line")
                    .attr("x1", line.x1)
                    .attr("y1", line.y1)
                    .attr("x2", line.x1)
                    .attr("y2", line.y1)
                    .attr("stroke", "#9b59b6")
                    .attr("stroke-width", 3)
                    .attr("stroke-dasharray", "5,3")
                    .attr("marker-end", "url(#inheritance-arrow)");
                
                l.transition()
                    .duration(600)
                    .delay(i * 200 + 500)
                    .attr("x2", line.x2)
                    .attr("y2", line.y2);
            });
            
            // Arrow marker for inheritance
            defs.append("marker")
                .attr("id", "inheritance-arrow")
                .attr("markerWidth", 10)
                .attr("markerHeight", 10)
                .attr("refX", 5)
                .attr("refY", 5)
                .attr("orient", "auto")
                .append("polygon")
                .attr("points", "0,0 10,5 0,10")
                .attr("fill", "#9b59b6");
            
            // Registration arrows
            const regArrows = [
                { x1: 230, y1: 250, x2: 750, y2: 185, label: "registers" },
                { x1: 430, y1: 250, x2: 800, y2: 185, label: "registers" },
                { x1: 620, y1: 250, x2: 850, y2: 185, label: "registers" }
            ];
            
            regArrows.forEach((arrow, i) => {
                const line = svg.append("line")
                    .attr("x1", arrow.x1)
                    .attr("y1", arrow.y1)
                    .attr("x2", arrow.x1)
                    .attr("y2", arrow.y1)
                    .attr("stroke", "#f39c12")
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.7)
                    .attr("marker-end", "url(#reg-arrow)");
                
                line.transition()
                    .duration(500)
                    .delay(i * 150 + 1500)
                    .attr("x2", arrow.x2)
                    .attr("y2", arrow.y2);
            });
            
            // Arrow for registration
            defs.append("marker")
                .attr("id", "reg-arrow")
                .attr("markerWidth", 8)
                .attr("markerHeight", 8)
                .attr("refX", 4)
                .attr("refY", 4)
                .attr("orient", "auto")
                .append("polygon")
                .attr("points", "0,0 8,4 0,8")
                .attr("fill", "#f39c12");
            
            // Context usage arrow
            svg.append("line")
                .attr("x1", 860)
                .attr("y1", 245)
                .attr("x2", 860)
                .attr("y2", 245)
                .attr("stroke", "#16a085")
                .attr("stroke-width", 3)
                .attr("marker-end", "url(#context-arrow)")
                .transition()
                .duration(500)
                .delay(2200)
                .attr("y2", 320);
            
            defs.append("marker")
                .attr("id", "context-arrow")
                .attr("markerWidth", 10)
                .attr("markerHeight", 10)
                .attr("refX", 5)
                .attr("refY", 5)
                .attr("orient", "auto")
                .append("polygon")
                .attr("points", "0,0 10,5 0,10")
                .attr("fill", "#16a085");
            
            svg.append("text")
                .attr("x", 870)
                .attr("y", 280)
                .attr("font-size", "11px")
                .attr("fill", "#16a085")
                .attr("font-weight", "bold")
                .attr("opacity", 0)
                .text("uses")
                .transition()
                .duration(300)
                .delay(2700)
                .attr("opacity", 1);
            
            // Draw class boxes
            classes.forEach((cls, i) => {
                const classGroup = svg.append("g")
                    .attr("class", "viz-node")
                    .style("cursor", "pointer");
                
                // Box
                const rect = classGroup.append("rect")
                    .attr("x", cls.x)
                    .attr("y", cls.y)
                    .attr("width", 0)
                    .attr("height", cls.height)
                    .attr("rx", 8)
                    .attr("fill", cls.color)
                    .attr("stroke", "white")
                    .attr("stroke-width", 3)
                    .attr("filter", "url(#box-shadow)");
                
                rect.transition()
                    .duration(500)
                    .delay(i * 100)
                    .attr("width", cls.width);
                
                // Class name
                classGroup.append("text")
                    .attr("x", cls.x + cls.width / 2)
                    .attr("y", cls.y + 20)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .attr("fill", "white")
                    .attr("opacity", 0)
                    .text(cls.name)
                    .transition()
                    .duration(300)
                    .delay(i * 100 + 500)
                    .attr("opacity", 1);
                
                // Separator line
                classGroup.append("line")
                    .attr("x1", cls.x + 10)
                    .attr("y1", cls.y + 30)
                    .attr("x2", cls.x + cls.width - 10)
                    .attr("y2", cls.y + 30)
                    .attr("stroke", "rgba(255,255,255,0.4)")
                    .attr("stroke-width", 1)
                    .attr("opacity", 0)
                    .transition()
                    .duration(200)
                    .delay(i * 100 + 600)
                    .attr("opacity", 1);
                
                // Methods
                cls.methods.forEach((method, mi) => {
                    classGroup.append("text")
                        .attr("x", cls.x + 10)
                        .attr("y", cls.y + 48 + mi * 18)
                        .attr("font-size", "11px")
                        .attr("fill", "rgba(255,255,255,0.95)")
                        .attr("opacity", 0)
                        .text("+ " + method)
                        .transition()
                        .duration(200)
                        .delay(i * 100 + 700 + mi * 100)
                        .attr("opacity", 1);
                });
                
                // Hover tooltip
                classGroup.on("mouseover", function(event) {
                    d3.select(this).select("rect")
                        .transition()
                        .duration(200)
                        .attr("stroke-width", 5);
                    
                    const tooltip = d3.select("#tooltip");
                    tooltip.html(`
                        <h4>${cls.name}</h4>
                        <p>${cls.desc}</p>
                        <p><strong>Methods:</strong></p>
                        <code>${cls.methods.join('<br>')}</code>
                    `);
                    tooltip.classed("show", true);
                    
                    const rect = event.target.getBoundingClientRect();
                    tooltip.style("left", (rect.left) + "px")
                           .style("top", (rect.bottom + 10) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this).select("rect")
                        .transition()
                        .duration(200)
                        .attr("stroke-width", 3);
                    
                    d3.select("#tooltip").classed("show", false);
                });
            });
            
            // Add legend
            const legendItems = [
                { text: "Inheritance (extends)", color: "#9b59b6", y: 480 },
                { text: "Registration (registers with)", color: "#f39c12", y: 505 },
                { text: "Usage (uses for lookup)", color: "#16a085", y: 530 }
            ];
            
            legendItems.forEach(item => {
                svg.append("line")
                    .attr("x1", 50)
                    .attr("y1", item.y)
                    .attr("x2", 90)
                    .attr("y2", item.y)
                    .attr("stroke", item.color)
                    .attr("stroke-width", 3)
                    .attr("stroke-dasharray", item.text.includes("Inheritance") ? "5,3" : "0");
                
                svg.append("text")
                    .attr("x", 100)
                    .attr("y", item.y + 4)
                    .attr("font-size", "12px")
                    .attr("fill", "#333")
                    .text(item.text);
            });
        }
        
        function animateTagLibrary() {
            createTagLibrary();
        }
        
        function resetTagLibrary() {
            createTagLibrary();
        }
        
        // Tag Processing Visualization - Enhanced
        function createTagProcessing() {
            const container = d3.select("#flowchart");
            container.selectAll("*").remove();
            
            const width = 1200;
            const height = 600;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Add shadow filter
            const defs = svg.append("defs");
            const filter = defs.append("filter")
                .attr("id", "box-shadow")
                .attr("height", "130%");
            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 4);
            filter.append("feOffset")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetblur");
            filter.append("feComponentTransfer")
                .append("feFuncA")
                .attr("type", "linear")
                .attr("slope", 0.3);
            const feMerge = filter.append("feMerge");
            feMerge.append("feMergeNode");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");
            
            const steps = [
                { x: 600, y: 50, text: "Parser Encounters", text2: "<app:sqlQuery>", color: "#3498db",
                  detail: "XML parser encounters custom tag while processing template",
                  code: "<app:sqlQuery var='users'>SELECT * FROM users</app:sqlQuery>" },
                { x: 600, y: 130, text: "Lookup 'app'", text2: "AppTagLibrary", color: "#9b59b6",
                  detail: "JellyContext looks up 'app' namespace to find registered tag library",
                  code: "context.registerTagLibrary('app', new AppTagLibrary())" },
                { x: 600, y: 210, text: "Lookup 'sqlQuery'", text2: "SqlQueryTag.class", color: "#9b59b6",
                  detail: "AppTagLibrary maps 'sqlQuery' tag name to SqlQueryTag.class",
                  code: "registerTag('sqlQuery', SqlQueryTag.class)" },
                { x: 600, y: 290, text: "Create Instance", text2: "new SqlQueryTag()", color: "#e74c3c",
                  detail: "Jelly engine instantiates new SqlQueryTag object for this specific tag occurrence",
                  code: "SqlQueryTag tag = (SqlQueryTag) tagClass.newInstance()" },
                { x: 600, y: 370, text: "Set Attributes", text2: "setVar('users')", color: "#e74c3c",
                  detail: "Tag attributes are set via setter methods before execution",
                  code: "tag.setVar('users'); tag.setContext(jellyContext);" },
                { x: 600, y: 450, text: "Execute doTag()", text2: "Run SQL Query", color: "#f39c12",
                  detail: "doTag() extracts SQL from body, gets DB connection, executes query",
                  code: "String sql = getBodyText(); ResultSet rs = stmt.executeQuery(sql);" },
                { x: 600, y: 530, text: "Store in Context", text2: "setVariable()", color: "#27ae60",
                  detail: "Query results stored in JellyContext for access by other tags",
                  code: "context.setVariable('users', resultList); context.setVariable('users_count', size);" }
            ];
            
            // Draw connecting arrows with animation
            for (let i = 0; i < steps.length - 1; i++) {
                const line = svg.append("line")
                    .attr("x1", steps[i].x)
                    .attr("y1", steps[i].y + 30)
                    .attr("x2", steps[i].x)
                    .attr("y2", steps[i].y + 30)
                    .attr("stroke", "#95a5a6")
                    .attr("stroke-width", 4)
                    .attr("opacity", 0.7);
                
                line.transition()
                    .duration(400)
                    .delay(i * 150)
                    .attr("x2", steps[i + 1].x)
                    .attr("y2", steps[i + 1].y - 30);
                
                // Arrow head with animation
                const arrow = svg.append("polygon")
                    .attr("points", `${steps[i + 1].x},${steps[i + 1].y - 30} ${steps[i + 1].x - 7},${steps[i + 1].y - 42} ${steps[i + 1].x + 7},${steps[i + 1].y - 42}`)
                    .attr("fill", "#95a5a6")
                    .attr("opacity", 0);
                
                arrow.transition()
                    .duration(200)
                    .delay(i * 150 + 400)
                    .attr("opacity", 0.7);
            }
            
            // Draw step boxes with enhanced styling
            steps.forEach((step, i) => {
                const stepGroup = svg.append("g")
                    .attr("class", "viz-node")
                    .style("cursor", "pointer");
                
                // Rectangle with shadow and animation
                const rect = stepGroup.append("rect")
                    .attr("x", step.x - 110)
                    .attr("y", step.y - 28)
                    .attr("width", 0)
                    .attr("height", 56)
                    .attr("rx", 12)
                    .attr("fill", step.color)
                    .attr("stroke", "white")
                    .attr("stroke-width", 3)
                    .attr("filter", "url(#box-shadow)");
                
                rect.transition()
                    .duration(500)
                    .delay(i * 150)
                    .attr("x", step.x - 110)
                    .attr("width", 220);
                
                // Inner glow
                stepGroup.append("rect")
                    .attr("x", step.x - 105)
                    .attr("y", step.y - 23)
                    .attr("width", 210)
                    .attr("height", 46)
                    .attr("rx", 10)
                    .attr("fill", "none")
                    .attr("stroke", "rgba(255,255,255,0.3)")
                    .attr("stroke-width", 2)
                    .attr("opacity", 0)
                    .transition()
                    .duration(300)
                    .delay(i * 150 + 500)
                    .attr("opacity", 1);
                
                // Text line 1
                stepGroup.append("text")
                    .attr("x", step.x)
                    .attr("y", step.y - 6)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .attr("opacity", 0)
                    .text(step.text)
                    .transition()
                    .duration(300)
                    .delay(i * 150 + 600)
                    .attr("opacity", 1);
                
                // Text line 2
                stepGroup.append("text")
                    .attr("x", step.x)
                    .attr("y", step.y + 13)
                    .attr("text-anchor", "middle")
                    .attr("fill", "rgba(255,255,255,0.9)")
                    .attr("font-size", "12px")
                    .attr("opacity", 0)
                    .text(step.text2)
                    .transition()
                    .duration(300)
                    .delay(i * 150 + 700)
                    .attr("opacity", 1);
                
                // Enhanced hover effect with tooltip
                stepGroup.on("mouseover", function(event) {
                    d3.select(this).select("rect")
                        .transition()
                        .duration(200)
                        .attr("stroke-width", 5)
                        .attr("transform", "scale(1.05)");
                    
                    // Show detailed tooltip
                    const tooltip = d3.select("#tooltip");
                    tooltip.html(`
                        <h4>${step.text}</h4>
                        <p><strong>Action:</strong> ${step.detail}</p>
                        <p><strong>Code:</strong></p>
                        <code>${step.code}</code>
                    `);
                    tooltip.classed("show", true);
                    
                    // Position tooltip
                    const rect = event.target.getBoundingClientRect();
                    tooltip.style("left", (rect.right + 20) + "px")
                           .style("top", (rect.top) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this).select("rect")
                        .transition()
                        .duration(200)
                        .attr("stroke-width", 3)
                        .attr("transform", "scale(1)");
                    
                    d3.select("#tooltip").classed("show", false);
                });
            });
        }
        
        function animateTagProcessing() {
            // Recreate with animation
            createTagProcessing();
        }
        
        function resetTagProcessing() {
            createTagProcessing();
        }
        
        // Initialize visualizations on page load
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                createLifecycle();
                createTagLibrary();
                createTagProcessing();
            }, 100);
        });
        
        // Fallback if DOMContentLoaded already fired
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(() => {
                createLifecycle();
                createTagLibrary();
                createTagProcessing();
            }, 100);
        }
    ]]></script>
</body>
</html>
</j:jelly>
